{
  "categories": [
    {
      "name": "Variables",
      "description": "Variables are symbols that are used to store data values. In JavaScript, variables can be declared using 'var', 'let', or 'const'.",
      "concepts": [
        {
          "term": "var",
          "description": "Declares a variable, optionally initializing it to a value.",
          "code": "var name = 'John';"
        },
        {
          "term": "let",
          "description": "Declares a block-scoped, local variable, optionally initializing it to a value.",
          "code": "let age = 30;"
        },
        {
          "term": "const",
          "description": "Declares a block-scoped, read-only named constant.",
          "code": "const birthday = '01/01/1990';"
        }
      ]
    },
    {
      "name": "Data Types",
      "description": "Data types in JavaScript specify the different types of values that can be stored and manipulated within a program.",
      "concepts": [
        {
          "term": "String",
          "description": "Represents textual data.",
          "code": "let greeting = \"Hello, World!\";"
        },
        {
          "term": "Number",
          "description": "Represents both integer and floating-point numbers.",
          "code": "let score = 25;"
        },
        {
          "term": "Boolean",
          "description": "Represents a logical entity having two values: true and false.",
          "code": "let isAdult = true;"
        },
        {
          "term": "Object",
          "description": "Used to store collections of data and more complex entities.",
          "code": "let person = {firstName: \"John\", lastName: \"Doe\"};"
        },
        {
          "term": "Array",
          "description": "Used to store multiple values in a single variable.",
          "code": "let colors = ['Red', 'Green', 'Blue'];"
        },
        {
          "term": "Null",
          "description": "Represents the intentional absence of any object value.",
          "code": "let empty = null;"
        },
        {
          "term": "Undefined",
          "description": "Indicates that a variable has not been assigned a value.",
          "code": "let und;"
        }
      ]
    },
    {
      "name": "Operators",
      "description": "Operators are symbols that tell the compiler or interpreter to perform specific mathematical, relational or logical operations and produce final results.",
      "concepts": [
        {
          "term": "Arithmetic",
          "description": "Perform mathematical calculations.",
          "code": "let sum = 10 + 5; // 15"
        },
        {
          "term": "Assignment",
          "description": "Assign values to JavaScript variables.",
          "code": "let x = 10;"
        },
        {
          "term": "Comparison",
          "description": "Compare two values and return true or false.",
          "code": "let isEqual = (x == 10); // true"
        },
        {
          "term": "Logical",
          "description": "Used to determine the logic between variables or values.",
          "code": "let isGreater = (x > 5) && (x < 15); // true"
        },
        {
          "term": "Unary",
          "description": "Operate on a single operand.",
          "code": "x++;"
        },
        {
          "term": "Ternary (Conditional)",
          "description": "Assign a value to a variable based on some condition.",
          "code": "let result = (x > 10) ? 'Greater than 10' : 'Less than or equal to 10';"
        }
      ]
    },
    {
      "name": "Control Flow",
      "description": "Control flow statements determine the order in which the code executes in a script.",
      "concepts": [
        {
          "term": "if statement",
          "description": "Executes a block of code if a specified condition is true.",
          "code": "if (x > 10) {\n  console.log('x is greater than 10');\n}"
        },
        {
          "term": "else statement",
          "description": "Executes a block of code if the same condition is false.",
          "code": "else {\n  console.log('x is not greater than 10');\n}"
        },
        {
          "term": "else if statement",
          "description": "Specifies a new condition to test if the first condition is false.",
          "code": "else if (x == 10) {\n  console.log('x is equal to 10');\n}"
        },
        {
          "term": "switch statement",
          "description": "Specifies many alternative blocks of code to be executed.",
          "code": "switch (x) {\n  case 10:\n    console.log('x is 10');\n    break;\n  default:\n    console.log('x is not 10');\n}"
        },
        {
          "term": "for loop",
          "description": "Loops through a block of code a number of times.",
          "code": "for (let i = 0; i < 5; i++) {\n  console.log(i);\n}"
        },
        {
          "term": "while loop",
          "description": "Loops through a block of code as long as a specified condition is true.",
          "code": "let i = 0;\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}"
        },
        {
          "term": "do-while loop",
          "description": "Also loops through a block of code as long as a specified condition is true.",
          "code": "do {\n  console.log(i);\n  i++;\n} while (i < 5);"
        }
      ]
    },
    {
      "name": "Debugging",
      "description": "Debugging is the process of identifying and removing errors from software applications, and it's crucial for software development.",
      "concepts": [
        {
          "term": "Console.log()",
          "description": "Logs information to the browser's console, which is useful for debugging purposes.",
          "code": "console.log('Debug message');"
        },
        {
          "term": "Breakpoints",
          "description": "A debugging tool that allows developers to pause the execution of code at a specific line.",
          "code": "// Typically set within developer tools in a browser or IDE."
        },
        {
          "term": "DevTools",
          "description": "Web developer tools available in most browsers to help in debugging web applications.",
          "code": "// Access via right-clicking the page and selecting 'Inspect' or with 'Ctrl+Shift+I'."
        }
      ]
    },

    {
      "name": "Libraries and Frameworks",
      "description": "Frameworks and libraries are collections of pre-written code to help developers build applications faster by providing reusable components and abstracting complex operations.",
      "concepts": [
        {
          "term": "React",
          "description": "A JavaScript library for building user interfaces, particularly single-page applications.",
          "code": "import React from 'react';"
        },
        {
          "term": "Angular",
          "description": "A platform and framework for building client-side single-page applications using HTML and TypeScript.",
          "code": "import { Component } from '@angular/core';"
        },
        {
          "term": "Vue.js",
          "description": "A progressive framework for building user interfaces, focusing on the view layer.",
          "code": "import Vue from 'vue';"
        }
      ]
    },
    {
      "name": "Testing and Performance",
      "description": "Testing and performance optimization are crucial for developing efficient, reliable, and scalable web applications.",
      "concepts": [
        {
          "term": "Unit Testing",
          "description": "A software testing method by which individual units of source code are tested to determine whether they are fit for use.",
          "code": "describe('addition', () => { it('correctly adds two numbers', () => { expect(1 + 1).toBe(2); }); });"
        },
        {
          "term": "Performance Tuning",
          "description": "The process of making a system perform better. This can involve optimizing code, reducing unnecessary computations, and using efficient algorithms.",
          "code": "// Example code specific to performance tuning is highly contextual"
        }
      ]
    },
    {
      "name": "Functions",
        "description": "Functions are blocks of code designed to perform a particular task, and they are executed when something invokes or calls them.",
        "concepts": [
          {
            "term": "Function declaration",
            "description": "Declares a function with the specified parameters.",
            "code": "function greet(name) { return 'Hello, ' + name + '!'; }"
          },
          {
            "term": "Function expression",
            "description": "A function can also be defined using an expression.",
            "code": "let greet = function(name) { return 'Hello, ' + name + '!'; };"
          },
          {
            "term": "Arrow function",
            "description": "Allows a short syntax for writing function expressions.",
            "code": "let greet = name => 'Hello, ' + name + '!';"
          },
          {
            "term": "IIFE (Immediately Invoked Function Expression)",
            "description": "A function that runs as soon as it is defined.",
            "code": "(function () { console.log('Immediately invoked'); })();"
          }
        ]
      },
      {  "name": "Scope",
        "description": "Scope determines the accessibility of variables and functions in JavaScript. Variables can exist in local or global scopes.",
        "concepts": [
          {
            "term": "Global scope",
            "description": "Variables defined outside any function have global scope.",
            "code": "var globalVar = 'I am global';"
          },
          {
            "term": "Local scope",
            "description": "Variables declared within a function are local to that function.",
            "code": "function myFunction() { var localVar = 'I am local'; }"
          },
          {
            "term": "Block scope",
            "description": "`let` and `const` are scoped to the block in which they are defined.",
            "code": "if (true) { let blockScopedVar = 'I am block scoped'; }"
          },
          {
            "term": "Lexical scope",
            "description": "Describes how a parser resolves variable names when functions are nested.",
            "code": "function outerFunc() { var outerVar = 'I am outside!'; function innerFunc() { console.log(outerVar); } innerFunc(); } outerFunc();"
          }
        ]
      },
      { "name":  "Array Methods",
        "description": "Array methods are built-in functions that allow manipulation of array items, including searching, sorting, iterating, and transforming array elements.",
        "concepts": [
          {
            "term": "push()",
            "description": "Adds one or more elements to the end of an array   and returns the new length of the array.",
            "code": "let fruits = ['apple', 'banana']; fruits.push('orange');"
          },
          {
            "term": "pop()",
            "description": "Removes the last element from an array and returns that element.",
            "code": "let fruits = ['apple', 'banana', 'orange']; let last = fruits.pop();"
          },
          {
            "term": "shift()",
            "description": "Removes the first element from an array and returns that removed element.",
            "code": "let fruits = ['apple', 'banana', 'orange']; let first = fruits.shift();"
          },
          {
            "term": "unshift()",
            "description": "Adds one or more elements to the beginning of an array and returns the new length.",
            "code": "let fruits = ['banana', 'orange']; fruits.unshift('apple');"
          },
          {
            "term": "splice()",
            "description": "Changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.",
            "code": "colors.splice(2, 0, \"Orange\"); // Adds 'Orange' at index 2"
          },
          {
            "term": "slice()",
            "description": "Returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included).",
            "code": "let newColors = colors.slice(1, 3); // Copies elements at index 1 to 2"
          },
          {
            "term": "concat()",
            "description": "Is used to merge two or more arrays.",
            "code": "let moreColors = [\"Pink\", \"Black\"]; let combinedColors = colors.concat(moreColors); // Merges two arrays"
          }
        ]
      },
       {
        "name":"Array Iteration",
        "description": "Array  methods execute a function on each item of an array, enabling operations like finding, filtering, and transforming array elements.",
        "concepts": [
          {
            "term": "forEach()",
            "description": "Executes a provided function once for each array element.",
            "code": "let numbers = [1, 2, 3, 4, 5]; numbers.forEach(number => console.log(number));"
          },
          {
            "term": "map()",
            "description": "Creates a new array populated with the results of calling a provided function on every element in the calling array.",
            "code": "let numbers = [1, 2, 3, 4, 5]; let squares = numbers.map(number => number * number);"
          },
          {
            "term": "filter()",
            "description": "Creates a new array with all elements that pass the test implemented by the provided function.",
            "code": "let numbers = [1, 2, 3, 4, 5]; let evens = numbers.filter(number => number % 2 === 0);"
          },
          {
            "term": "reduce()",
            "description": "Executes a reducer function on each element of the array, resulting in a single output value.",
            "code": "let numbers = [1, 2, 3, 4, 5]; let sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);"
          }
        ]
      },
       { "name": "Web APIs",
        "description": "Web APIs enable interaction between the web browser and the web page, providing functionalities like manipulating the Document Object Model (DOM), making HTTP requests, and storing data on the client side.",
        "concepts": [
          {
            "term": "Fetch API",
            "description": "Provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.",
            "code": "fetch('https://api.example.com/data').then(response => response.json()).then(data => console.log(data));"
          },
          {
            "term": "DOM Manipulation",
            "description": "Allows dynamic changes to the content, structure, and style of a website.",
            "code": "document.getElementById('demo').textContent = 'Hello World!';"
          },
          {
            "term": "Event Listeners",
            "description": "Asynchronous callbacks that listen for events on web page elements.",
            "code": "document.getElementById('btn').addEventListener('click', () => alert('Button clicked!'));"
          },
          {
            "term": "Local Storage",
            "description": "Provides a way to store data locally within the user's browser.",
            "code": "localStorage.setItem('key', 'value'); console.log(localStorage.getItem('key'));"
          },
          {
            "term": "Session Storage",
            "description": "Similar to Local Storage, but it's cleared when the page session ends.",
            "code": "sessionStorage.setItem('sessionKey', 'sessionValue'); console.log(sessionStorage.getItem('sessionKey'));"
          }
        ]
      },
       { "name": "AJAX (Asynchronous JavaScript and XML)",
        "description": "ES6, officially known as ECMAScript 2015, and later versions introduced new syntax and features to make JavaScript more powerful and concise.",
        "concepts": [
          {
            "term": "Arrow Functions",
            "description": "Provides a concise syntax for writing functions in JavaScript.",
            "code": "const add = (a, b) => a + b;"
          },
          {
            "term": "Promises",
            "description": "An object representing the eventual completion or failure of an asynchronous operation.",
            "code": "const fetchData = new Promise((resolve, reject) => { /* async operation */ });"
          },
          {
            "term": "Template Literals",
            "description": "Allow embedded expressions within string literals.",
            "code": "const greeting = `Hello, ${name}!`;"
          },
          {
            "term": "Destructuring Assignment",
            "description": "Makes it possible to unpack values from arrays, or properties from objects, into distinct variables.",
            "code": "const {a, b} = {a: 1, b: 2};"
          },
          {
            "term": "Default Parameters",
            "description": "Allow named parameters to be initialized with default values if no value or undefined is passed.",
            "code": "function greet(name = 'Guest') { return `Hello, ${name}!`; }"
          },
          {
            "term": "let and const",
            "description": "Introduce block-scope variable declarations for JavaScript.",
            "code": "let a = 2; const b = 'constant';"
          },
          {
            "term": "Modules",
            "description": "ECMAScript modules are the official standard format to package JavaScript code for reuse.",
            "code": "import { moduleFunction } from './module.js'; export function myFunction() { /*...*/ }"
          }
        ]
      },
      {
        "name": "Objects",
        "description": "Objects in JavaScript are collections of key/value pairs. They store data and provide a mechanism for encapsulating data, functions, and structures.",
        "concepts": [
          {
            "term": "Object properties",
            "description": "Includes dot notation and bracket notation for accessing properties.",
            "code": "let person = {firstName: \"John\", lastName: \"Doe\"};\n// Examples for dot and bracket notation"
          },
          {
            "term": "Object methods",
            "description": "Includes `Object.keys()`, `Object.values()`, `Object.entries()`.",
            "code": "let person = {firstName: \"John\", lastName: \"Doe\"};\n// Examples for each object method"
          },
          {
            "term": "Object destructuring",
            "description": "A JavaScript expression that allows unpacking values from arrays, or properties from objects, into distinct variables.",
            "code": "let {firstName, lastName} = person;"
          }, {
            "term": "Dot notation",
            "description": "Accesses the property of an object. It's a straightforward syntax for getting or setting an object's property when you know the name of the property.",
            "code": "let person = {firstName: 'John', lastName: 'Doe'};\nconsole.log(person.firstName); // 'John'"
          },
          {
            "term": "Bracket notation",
            "description": "Another way to access a property of an object. It's useful when the property name is dynamic or not a valid identifier.",
            "code": "let person = {firstName: 'John', lastName: 'Doe'};\nlet property = 'firstName';\nconsole.log(person[property]); // 'John'"
          },
          {
            "term": "Object.keys()",
            "description": "Returns an array of a given object's own property names, in the same order as we get with a normal loop.",
            "code": "let person = {firstName: 'John', lastName: 'Doe'};\nconsole.log(Object.keys(person)); // ['firstName', 'lastName']"
          },
          {
            "term": "Object.values()",
            "description": "Returns an array of a given object's own enumerable property values, in the same order as that provided by a for...in loop.",
            "code": "let person = {firstName: 'John', lastName: 'Doe'};\nconsole.log(Object.values(person)); // ['John', 'Doe']"
          },
          {
            "term": "Object.entries()",
            "description": "Returns an array of a given object's own enumerable string-keyed property [key, value] pairs.",
            "code": "let person = {firstName: 'John', lastName: 'Doe'};\nconsole.log(Object.entries(person)); // [['firstName', 'John'], ['lastName', 'Doe']]"
          }
        ]
      },
      {
        "name": "Promises",
        "description": "Promises are used for asynchronous computations. A Promise represents an operation that hasn't completed yet, but is expected in the future.",
        "concepts": [
          {
            "term": "Promise states",
            "description": "Includes Pending, Fulfilled, Rejected.",
            "code": "// Examples for each state here"
          },
          {
            "term": "Promise methods",
            "description": "Includes `then()`, `catch()`, `finally()`, `Promise.all()`.",
            "code": "// Examples for using promise methods"
          },
          {
            "term": "Pending",
            "description": "The initial state of a Promise. The operation represented by the Promise has not completed yet.",
            "code": "const promise = new Promise((resolve, reject) => {}); // Promise is in 'Pending' state"
          },
          {
            "term": "Fulfilled",
            "description": "The state of a Promise representing a successful operation.",
            "code": "const promise = Promise.resolve('Success');\npromise.then(result => console.log(result)); // 'Success', Promise is 'Fulfilled'"
          },
          {
            "term": "Rejected",
            "description": "The state of a Promise representing a failed operation.",
            "code": "const promise = Promise.reject('Failure');\npromise.catch(error => console.log(error)); // 'Failure', Promise is 'Rejected'"
          },
          {
            "term": "then()",
            "description": "Method to handle the fulfillment of the Promise. It gets called when the Promise is fulfilled.",
            "code": "Promise.resolve('Success').then(result => console.log(result)); // Logs 'Success'"
          },
          {
            "term": "catch()",
            "description": "Method to handle the rejection of the Promise. It is executed when the Promise is rejected.",
            "code": "Promise.reject('Failure').catch(error => console.log(error)); // Logs 'Failure'"
          },
          {
            "term": "finally()",
            "description": "Method that executes a callback function once the Promise is either fulfilled or rejected.",
            "code": "new Promise((resolve, reject) => {\n  resolve('Success');\n})\n.finally(() => console.log('Completed'));\n// Logs 'Completed' regardless of the Promise's outcome"
          },
          {
            "term": "Promise.all()",
            "description": "Method that takes an iterable of promises as an input, and returns a single Promise that resolves when all of the promises in the iterable have resolved.",
            "code": "Promise.all([Promise.resolve('Promise 1'), Promise.resolve('Promise 2')])\n.then(results => console.log(results)); // Logs ['Promise 1', 'Promise 2']"
          }
        ]
      },
      {
        "name": "Asynchronous JavaScript",
        "description": "Asynchronous JavaScript includes techniques such as callbacks, promises, and async/await to handle or perform operations asynchronously.",
        "concepts": [
          {
            "term": "Callbacks",
            "description": "A function passed into another function as an argument to be executed later.",
            "code": "// Example of a callback function"
          },
          {
            "term": "Promises",
            "description": "An object representing the eventual completion or failure of an asynchronous operation.",
            "code": "// Example of creating a promise"
          },
          {
            "term": "Async/Await",
            "description": "A syntactic sugar built on top of promises, making asynchronous code look and behave a little more like synchronous code.",
            "code": "// Example of using async/await"
          }
        ]
      },
      {
        "name": "Error Handling",
        "description": "Error handling in JavaScript is implemented using try...catch statements, throw statements, and custom error handling logic to manage exceptions.",
        "concepts": [
          {
            "term": "try...catch statement",
            "description": "Marks a block of statements to try, and specifies a response, should an exception be thrown.",
            "code": "// Example of using try...catch"
          },
          {
            "term": "throw statement",
            "description": "Throws a user-defined exception.",
            "code": "// Example of using throw"
          }
        ],
        "JSON (JavaScript Object Notation)": [
          {
            "term": "JSON",
            "description": "A syntax for storing and exchanging data.",
            "code": "let json = '{\"name\": \"John\", \"age\": 30}';\nlet user = JSON.parse(json); // Converts JSON text into a JavaScript object"
          }
        ]
      },
      {
        "name": "JSON (JavaScript Object Notation)",
        "description": "JSON is a lightweight format for storing and transporting data, often used when data is sent from a server to a web page.",
        "concepts": [
          {
            "term": "JSON",
            "description": "A syntax for storing and exchanging data.",
            "code": "let json = '{\"name\": \"John\", \"age\": 30}';"
          }
        ]
      },
      {
        "name": "Security",
        "description": "Security in JavaScript involves techniques and practices for protecting web applications against vulnerabilities and threats, such as Cross-Site Scripting (XSS) and other web-based attacks.",
        "concepts": [
          {
            "term": "Cross-Site Scripting (XSS)",
            "description": "A security vulnerability typically found in web applications that allows attackers to inject client-side scripts into web pages viewed by other users.",
            "code": ""
          }
        ]
      },
      {
        "name": "ES6+ Features Extended",
        "description": "Extended features of ES6 and later versions include syntax and functionality improvements like Optional Chaining and the Nullish Coalescing Operator.",
        "concepts": [
          {
            "term": "Optional Chaining",
            "description": "A safe way to access nested object properties, even if an intermediate property doesn't exist.",
            "code": "const streetName = user?.address?.street;"
          },
          {
            "term": "Nullish Coalescing Operator",
            "description": "A logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand.",
            "code": "const foo = null ?? 'default string';"
          }
        ]
      },
      {
        "name": "Modern Development Practices",
        "description": "Modern Development Practices include methodologies and technologies such as Service Workers and Web Components, enhancing the capabilities and performance of web applications.",
        "concepts": [
          {
            "term": "Service Workers",
            "description": "Scripts that your browser runs in the background, separate from a web page, opening the door to features that don't need a web page or user interaction.",
            "code": "if ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/service-worker.js');\n}"
          },
          {
            "term": "Web Components",
            "description": "A set of web platform APIs that allow you to create new custom, reusable, encapsulated HTML tags to use in web pages and web apps.",
            "code": "class MyComponent extends HTMLElement {\n  constructor() {\n    super();\n  }\n}\ncustomElements.define('my-component', MyComponent);"
          }
        ]
      },
      {
        "name": "Modules",
        "description": "Modules in JavaScript provide a way to split the code of a web application into independent, reusable pieces.",
        "concepts": [
          {
            "term": "import",
            "description": "Allows you to bring modules or specific features into your current file.",
            "code": "import { moduleFunction } from './module.js';"
          },
          {
            "term": "export",
            "description": "Allows you to make parts of your module available to be imported into other files.",
            "code": "export function moduleFunction() { ... }"
          }
        ]
      }, {
        "name": "DOM Manipulation",
        "description": "Techniques for dynamically changing the content, structure, and style of a document.",
        "concepts": [
          {
            "term": "Selecting elements",
            "description": "Accessing elements from the DOM.",
            "code": "let element = document.getElementById('myElement');"
          },
          {
            "term": "Modifying elements",
            "description": "Changing the content or style of elements.",
            "code": "element.textContent = 'New content';"
          },
          {
            "term": "Creating elements",
            "description": "Adding new elements to the DOM.",
            "code": "let newElement = document.createElement('div');\ndocument.body.appendChild(newElement);"
          }
        ]
      },
      {
        "name": "Events",
        "description": "Interactions or occurrences that happen within the system you are programming for, which can be captured and handled using JavaScript.",
        "concepts": [
          {
            "term": "Event listeners",
            "description": "Add a function that will be called whenever a specified event occurs.",
            "code": "element.addEventListener('click', function() {\n  console.log('Element clicked!');\n});"
          },
          {
            "term": "Event propagation",
            "description": "The process by which an event activated on an element (e.g., a click) is propagated through multiple layers of the DOM. Event propagation can be in two phases: capturing and bubbling.",
            "code": "document.getElementById('parent').addEventListener('click', function() {\n  console.log('Parent clicked!');\n}, false);\ndocument.getElementById('child').addEventListener('click', function(event) {\n  console.log('Child clicked!');\n  event.stopPropagation(); // Stops the propagation\n}, false);"
          },
          {
            "term": "Event delegation",
            "description": "A technique of handling events by adding a single event listener to a parent element rather than multiple listeners to individual child elements. It leverages the event bubbling phase to capture events from child elements.",
            "code": "document.getElementById('parent').addEventListener('click', function(event) {\n  if(event.target && event.target.matches('li.item')) {\n    console.log('Item clicked:', event.target.textContent);\n  }\n});"
          }
        ]
      },
      {
        "name": "AJAX (Asynchronous JavaScript and XML)",
        "description": "A technique for creating fast and dynamic web pages, allowing for asynchronous web page updates.",
        "concepts": [
          {
            "term": "AJAX",
            "description": "A technique for creating fast and dynamic web pages.",
            "code": "// Example of using AJAX"
          }
        ]
      },
      {
        "name": "Fetch API",
        "description": "Provides a modern interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.",
        "concepts": [
          {
            "term": "Fetch API",
            "description": "Provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.",
            "code": "// Example of using Fetch API"
          }
        ]
      },
      {
        "name": "ES6+ Features",
        "description": "Enhancements and new features introduced in ECMAScript 6 and later versions to improve JavaScript.",
        "concepts": [
          {
            "term": "Template literals",
            "description": "Allow embedded expressions and multi-line strings.",
            "code": "let greeting = `Hello, ${name}!`;"
          },
          {
            "term": "Destructuring assignment",
            "description": "Allows unpacking values from arrays or properties from objects.",
            "code": "let [first, second] = [1, 2];\nlet {firstName, lastName} = person;"
          },
          {
            "term": "Spread/rest operator",
            "description": "Allows an iterable to expand in places where 0+ arguments are expected.",
            "code": "let parts = ['shoulders', 'knees'];\nlet lyrics = ['head', ...parts, 'and', 'toes'];"
          },
          {
            "term": "Arrow functions",
            "description": "Provide a concise syntax for writing function expressions.",
            "code": "let add = (a, b) => a + b;"
          },
          {
            "term": "Classes",
            "description": "A template for creating objects.",
            "code": "class Person {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n}"
          },
          {
            "term": "let and const",
            "description": "Declare variables with block scope, with `let` allowing reassignment and `const` defining a constant reference.",
            "code": "let age = 25;\nconst name = 'John Doe';"
          },
          {
            "term": "Default parameters",
            "description": "Allow named parameters to be initialized with default values if no value or undefined is passed.",
            "code": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}"
          },
          {
            "term": "Modules",
            "description": "Support for import and export of functions, objects, or primitives from one module to another.",
            "code": "// In file math.js\nexport const add = (a, b) => a + b;\n// In another file\nimport { add } from './math.js';\nconsole.log(add(2, 3));"
          },
          {
            "term": "Promises ES6",
            "description": "An object representing the eventual completion or failure of an asynchronous operation.",
            "code": "const fetchData = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  if (/* operation successful */) {\n    resolve('Data fetched successfully');\n  } else {\n    reject('Error fetching data');\n  }\n});\nfetchData.then(data => console.log(data)).catch(error => console.log(error));"
          }
        ]
      },
      {
        "name": "Advanced JavaScript Concepts",
        "description": "Covers advanced features of JavaScript that enable more complex and powerful code patterns.",
        "concepts": [
          {
            "term": "Symbols",
            "description": "A primitive data type unique and immutable, used mainly as the key of an Object property.",
            "code": "let sym = Symbol('description');"
          },
          {
            "term": "Generators",
            "description": "Functions that can be exited and later re-entered, with their context saved across re-entrances.",
            "code": "function* generator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}"
          },
          {
            "term": "Proxy",
            "description": "An object that wraps another object and intercepts operations, like reading/writing properties and others, optionally providing custom behavior.",
            "code": "let proxy = new Proxy(target, handler);"
          }
        ]
      }
      
    
    
    
  ]
}
